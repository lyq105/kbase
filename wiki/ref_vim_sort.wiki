Vim 有排序函数和排序命令。排序函数可见: |sort()|。

                                                        *:sor* *:sort*
:[range]sor[t][!] [i][u][r][n][x][o] [/{pattern}/]
                        给 [range] 里的行排序。如果没有给出行范围，给所有行排
                        序。

                        带 [!] 则反向排序。

                        带 [i] 则忽略大小写。

                        带 [n] 则排序基于每行的第一个十进制数 (在 {pattern} 匹
                        配之后或之内)。
                        数值包含前导的 '-'。

                        带 [x] 则排序基于每行的第一个十六进制数 (在 {pattern}
                        匹配之后或之内)。忽略引导的 "0x" 或 "0X"。
                        数值包含前导的 '-'。

                        带 [o] 则排序基于每行的第一个八进制数 (在 {pattern} 匹
                        配之后或之内)。

                        带 [u] 则只保留完全相同的行的第一行 (如果带 [i]，忽略
                        大小写的区别)。
                        没有这个标志位，完全相同的行的序列会按照它们原来的顺序
                        被保留下来。
                        注意 引导和拖尾的空白差异会导致不相同的行。

                        如果指定 /{pattern}/ 并且没有 [r] 标志位，跳过匹配
                        {pattern} 的文本，使得排序在匹配之后的内容上进行。
                        除了斜杠以外，任何非字母的字符都可以。
                        例如，要按第二个逗号分隔的字段排序:
                                :sort /[^,]*,/
                        按虚拟第 10 列的文本排序 (从而忽略制表和空格的区别):
                                :sort /.*\%10v/
                        按每行的第一个数值排序，不管它前面有什么:
                                :sort /.\{-}\ze\d/
                        (说明: ".\{-}" 匹配任何文本，"\ze" 设置匹配结束位置，
                        \d 匹配单个数位。)
                        带 [r] 则排序在匹配 {pattern} 的文本上进行，而不是如上
                        所述的用它之后的文本。
                        例如，要按每行的前三个字母排序且只看这三个字母:
                                :sort /\a\a\a/ r

                        如果使用 {pattern}，不匹配 {pattern} 的行按照它们原来
                        的顺序被保留，但和匹配 {pattern} 的行分开。如果反向排
                        序，它们会以反向顺序出现，并在排序好的行之后。否则它们
                        会以原有顺序出现，在排序好的行之前。

                        如果 {pattern} 为空 (例如指定 //)，则使用最近使用的搜
                        索模式。这样你可以先试好模式，然后在执行。

注意 ":sort" 和 ":global" 一起使用并不能对匹配的行进行排序，这样做没有意义。

排序的细节取决于使用的库函数。不能保证它是 "稳定" 排序，也不能保证排序依赖于当
前的 locale。你要自己试试才知道。

排序可以被中断,但在整个过程里如果中断得太晚，最后可能会出现重复的行。这取决于
使用的系统库函数。

